# 合约交互逻辑梳理

## 1. 系统设置流程

## 2. 用户质押流程
### 用户选择池子 → 调用 deposit/depositETH → 更新奖励计算 → 质押成功

### 质押核心逻辑
#### 2.1  更新池子奖励
##### 作用：确保奖励计算基于最新状态，包括：
##### 更新 pool_.accMetaNodePerST（累计每单位质押奖励）
##### 更新 pool_.lastRewardBlock（最后奖励区块）
```solidity
updatePool(_pid);
```

#### 2.2  计算用户已有质押的待领取奖励
##### accST = 用户当前质押量 × 当前累计奖励率 ÷ 1e18
##### pendingMetaNode_ = accST - 用户已结算奖励
##### 如果 pendingMetaNode_ > 0，则累加到 user_.pendingMetaNode
```solidity
if (user_.stAmount > 0) {
    (bool success1, uint256 accST) = user_.stAmount.tryMul(pool_.accMetaNodePerST);
    require(success1, "user stAmount mul accMetaNodePerST overflow");
    (success1, accST) = accST.tryDiv(1 ether);
    require(success1, "accST div 1 ether overflow");
    
    (bool success2, uint256 pendingMetaNode_) = accST.trySub(user_.finishedMetaNode);
    require(success2, "accST sub finishedMetaNode overflow");

    if(pendingMetaNode_ > 0) {
        (bool success3, uint256 _pendingMetaNode) = user_.pendingMetaNode.tryAdd(pendingMetaNode_);
        require(success3, "user pendingMetaNode overflow");
        user_.pendingMetaNode = _pendingMetaNode;
    }
}
```
#### 2.3  更新用户质押数量
##### 将新质押数量加到用户现有质押量上
```solidity
if(_amount > 0) {
    (bool success4, uint256 stAmount) = user_.stAmount.tryAdd(_amount);
    require(success4, "user stAmount overflow");
    user_.stAmount = stAmount;
}

```

#### 2.4  更新池子总质押量
```solidity
(bool success5, uint256 stTokenAmount) = pool_.stTokenAmount.tryAdd(_amount);
require(success5, "pool stTokenAmount overflow");
pool_.stTokenAmount = stTokenAmount;
```

#### 2.5 更新用户已结算奖励基准
##### 关键逻辑：重置用户的 finishedMetaNode，使其等于 新质押量 × 当前奖励率
```solidity
(bool success6, uint256 finishedMetaNode) = user_.stAmount.tryMul(pool_.accMetaNodePerST);
require(success6, "user stAmount mul accMetaNodePerST overflow");

(success6, finishedMetaNode) = finishedMetaNode.tryDiv(1 ether);
require(success6, "finishedMetaNode div 1 ether overflow");

user_.finishedMetaNode = finishedMetaNode;
```

#### 总结
##### 结算历史奖励：计算并保存已有质押的奖励
##### 更新质押状态：增加用户和池子的质押量
##### 重置基准线：设置新的奖励计算起点
##### 确保原子性：所有操作在一个交易中完成

## 3. 取消质押流程

### 取消质押核心逻辑
#### 3.1  更新池子奖励状态
```solidity
updatePool(_pid);
```
#### 3.2  计算用户待领取奖励
##### 待领取奖励 = (当前质押量 × 当前累计奖励率) - 已结算奖励
```solidity
uint256 pendingMetaNode_ = user_.stAmount * pool_.accMetaNodePerST / (1 ether) - user_.finishedMetaNode;
```

#### 3.3 保存待领取奖励
##### 将计算出的奖励保存到 pendingMetaNode 中
##### 用户可以在之后通过 claim() 函数领取
```solidity
if(pendingMetaNode_ > 0) {
    user_.pendingMetaNode = user_.pendingMetaNode + pendingMetaNode_;
}
```

#### 3.4 减少用户质押量
##### 创建解锁请求，设置解锁时间（当前区块 + 锁定区块数）
```solidity 
if(_amount > 0) {
    user_.stAmount = user_.stAmount - _amount;
    // 创建解锁请求
    user_.requests.push(UnstakeRequest({
        amount: _amount,
        unlockBlocks: block.number + pool_.unstakeLockedBlocks
    }));
}
```
#### 3.5  更新池子总质押量
```solidity 
pool_.stTokenAmount = pool_.stTokenAmount - _amount;
```

#### 3.6  更新用户已结算奖励基准
##### 重置 finishedMetaNode 为新的基准值，基于：取消质押后的新质押量 当前的累计奖励率
```solidity 
user_.finishedMetaNode = user_.stAmount * pool_.accMetaNodePerST / (1 ether);
```

## 4. 奖励领取流程
#### 4.1 计算可取回金额
##### 遍历用户的所有取消质押请求：
#####  如果请求的解锁区块 <= 当前区块（已解锁）：
#####    累加到可取回金额
#####    记录需要移除的请求数量
#####  否则（遇到未解锁的请求）：
#####    跳出循环（因为请求按时间顺序排列）
```solidity
uint256 pendingWithdraw_;
uint256 popNum_;
for (uint256 i = 0; i < user_.requests.length; i++) {
    if (user_.requests[i].unlockBlocks > block.number) {
        break;
    }
    pendingWithdraw_ = pendingWithdraw_ + user_.requests[i].amount;
    popNum_++;
}
```
#### 4.2  清理已处理的请求
##### 假设 requests = [A(已解锁), B(已解锁), C(未解锁), D(未解锁)]
##### popNum_ = 2
##### 第一步：前移未处理元素
##### [0] = [2] → C
##### [1] = [3] → D
##### 数组变为: [C, D, C, D]
##### 第二步：移除末尾元素
##### pop() × 2次
##### 最终数组: [C, D]
```solidity
for (uint256 i = 0; i < user_.requests.length - popNum_; i++) {
    user_.requests[i] = user_.requests[i + popNum_];
}

for (uint256 i = 0; i < popNum_; i++) {
    user_.requests.pop();
}
```

#### 4.3 实际资产转账
##### ETH池（地址为0）：使用 _safeETHTransfer
##### ERC20池：使用 SafeERC20 的 safeTransfer
```solidity
if (pendingWithdraw_ > 0) {
    if (pool_.stTokenAddress == address(0x0)) {
        _safeETHTransfer(msg.sender, pendingWithdraw_);
    } else {
        IERC20(pool_.stTokenAddress).safeTransfer(msg.sender, pendingWithdraw_);
    }
}
```

#### 4.4 与 unstake() 的协同工作
```
用户调用 unstake(100)                   区块10000
    ↓
创建请求: UnstakeRequest(100, 17200)
    ↓
等待...                               区块10000 → 17300
    ↓
用户调用 withdraw()
    ↓
检查解锁状态，取回100代币
    ↓
实际转账到用户钱包
```


####  claim() 和 withdraw()比较
```
方面	    claim()	            withdraw()
操作对象	奖励代币 (MetaNode)	 质押本金 (ETH/ERC20)
资产来源	系统奖励	         用户自己的本金
时间限制	随时可以领取	      需要等待解锁期
前置操作	无需前置操作	      需要先调用 unstake()
状态影响	不影响质押状态        减少质押数量
```

####  claim() 核心算法 user_.stAmount * pool_.accMetaNodePerST / (1 ether) - user_.finishedMetaNode + user_.pendingMetaNode;
```
各部分含义详解
部分A：user_.stAmount * pool_.accMetaNodePerST / (1 ether)
用户当前应得的总奖励

user_.stAmount：用户当前质押数量
pool_.accMetaNodePerST：每单位质押代币累计获得的奖励（放大1e18倍）
除以 1 ether（即1e18）是为了还原实际奖励数量

部分B：- user_.finishedMetaNode
减去已结算的奖励基准

user_.finishedMetaNode：用户已经"记账"的奖励部分
这个值在每次质押/取消质押操作时更新

部分C：+ user_.pendingMetaNode
加上之前累积的待领取奖励

user_.pendingMetaNode：临时存储的奖励（主要在操作过程中保存）
```

## 5. 奖励分配机制

## 6. 安全特性